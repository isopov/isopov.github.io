<!doctype html><html lang=en><head><title>Growing goroutine stacks · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Go allows to run very lightweight goroutines and throw them away (for garbage collector) after they are no longer needed. You can execute any code inside them and this caode can allocate as much as needed. Both on stack and on heap. If goroutine stack is too small it grows. This grow is not free. Suppose you have a widely used function that needs to allocate a bit of memory on stack."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Growing goroutine stacks"><meta name=twitter:description content="Go allows to run very lightweight goroutines and throw them away (for garbage collector) after they are no longer needed. You can execute any code inside them and this caode can allocate as much as needed. Both on stack and on heap. If goroutine stack is too small it grows. This grow is not free. Suppose you have a widely used function that needs to allocate a bit of memory on stack."><meta property="og:title" content="Growing goroutine stacks"><meta property="og:description" content="Go allows to run very lightweight goroutines and throw them away (for garbage collector) after they are no longer needed. You can execute any code inside them and this caode can allocate as much as needed. Both on stack and on heap. If goroutine stack is too small it grows. This grow is not free. Suppose you have a widely used function that needs to allocate a bit of memory on stack."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/goroutine-stack-grow/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-24T20:22:39+03:00"><meta property="article:modified_time" content="2023-03-24T20:22:39+03:00"><link rel=canonical href=https://isopov.github.io/posts/goroutine-stack-grow/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/goroutine-stack-grow/>Growing goroutine stacks</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-03-24T20:22:39+03:00>March 24, 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/golang/>Golang</a></span></div></div></header><div class=post-content><p>Go allows to run very lightweight goroutines and throw them away (for garbage collector) after they are no longer needed. You can execute any code inside them and this caode can allocate as much as needed. Both on stack and on heap. If goroutine stack is too small it grows. This grow is not free. Suppose you have a widely used function that needs to allocate a bit of memory on stack. Depending on whether there is enough of memory on stack or not it will take different amount of time, since in some cases it will include time to grow the stack. It happens that a really common function time.Now() is allocating. So this effect can be demoed with this function. Consider the following program.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> depth := <span style=color:#ff0;font-weight:700>0</span>; depth &lt; <span style=color:#ff0;font-weight:700>1000</span>; depth++ {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>var</span> res time.Duration
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#ff0;font-weight:700>10_000</span>; i++ {
</span></span><span style=display:flex><span>			done := <span style=color:#fff;font-weight:700>make</span>(<span style=color:#fff;font-weight:700>chan</span> <span style=color:#fff;font-weight:700>struct</span>{})
</span></span><span style=display:flex><span>			<span style=color:#fff;font-weight:700>go</span> <span style=color:#fff;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>				res += twoNowsDiffInDepth(depth)
</span></span><span style=display:flex><span>				<span style=color:#fff;font-weight:700>close</span>(done)
</span></span><span style=display:flex><span>			}()
</span></span><span style=display:flex><span>			&lt;-done
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.Printf(<span style=color:#0ff;font-weight:700>&#34;%03d - %d\n&#34;</span>, depth, res)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> twoNowsDiffInDepth(depth <span style=color:#fff;font-weight:700>int</span>) time.Duration {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>if</span> depth == <span style=color:#ff0;font-weight:700>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>return</span> nowDiff(time.Now())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> twoNowsDiffInDepth(depth - <span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> nowDiff(t time.Time) time.Duration {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> time.Now().Sub(t)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output has 1000 lines, obviously. Each line has total number of nanoseconds to call time.Now() on stacks depth from 1 to 1000 in a fresh goroutine 10 thousand times. Usually it takes 400000-600000 nanoseconds. However on some stack depth the result is different. Here is some lines from the output.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>000 - 838890
</span></span><span style=display:flex><span>001 - 796577
</span></span><span style=display:flex><span>002 - 691937
</span></span><span style=display:flex><span>003 - 578079
</span></span><span style=display:flex><span>004 - 531705
</span></span><span style=display:flex><span>005 - 499433
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>017 - 405944
</span></span><span style=display:flex><span>018 - 9895890
</span></span><span style=display:flex><span>019 - 9742951
</span></span><span style=display:flex><span>020 - 594866
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>060 - 458445
</span></span><span style=display:flex><span>061 - 20673514
</span></span><span style=display:flex><span>062 - 20978750
</span></span><span style=display:flex><span>063 - 617336
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>145 - 470577
</span></span><span style=display:flex><span>146 - 42773890
</span></span><span style=display:flex><span>147 - 42822470
</span></span><span style=display:flex><span>148 - 462516
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>316 - 480823
</span></span><span style=display:flex><span>317 - 87866537
</span></span><span style=display:flex><span>318 - 89459648
</span></span><span style=display:flex><span>319 - 438552
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>657 - 504671
</span></span><span style=display:flex><span>658 - 177226079
</span></span><span style=display:flex><span>659 - 177820189
</span></span><span style=display:flex><span>660 - 484756
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>997 - 564084
</span></span><span style=display:flex><span>998 - 556363
</span></span><span style=display:flex><span>999 - 524782
</span></span></code></pre></div><p>It is clear that at some stack depths we run out of stack memory and need to create new stack and copy old stack to prefix of the new one. This operation takes time and the larger the stack the larger the cost. I found curious that without growing the stack the cost of calling time.Now() on different stack depths is constant. Sure there is price for unwinding stack if you want to return the value. Consider the following benchmark.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> Blackhole time.Time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> BenchmarkNow(b *testing.B) {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> depth := <span style=color:#ff0;font-weight:700>0</span>; depth &lt; <span style=color:#ff0;font-weight:700>100</span>; depth++ {
</span></span><span style=display:flex><span>		b.Run(<span style=color:#0ff;font-weight:700>&#34;Depth&#34;</span>+strconv.Itoa(depth), <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>			<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>				Blackhole = nowInDepth(depth)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> nowInDepth(depth <span style=color:#fff;font-weight:700>int</span>) time.Time {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>if</span> depth == <span style=color:#ff0;font-weight:700>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>return</span> time.Now()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> nowInDepth(depth - <span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here are the results with boring ones ommitted.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>BenchmarkNow/Depth0         		        41.12 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth1         		        38.26 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth2         		        38.82 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth3         		        39.13 ns/op
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>BenchmarkNow/Depth15        		        40.29 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth16        		        40.55 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth17        		        43.13 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth18        		       107.70 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth19        		       103.90 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth20        		       111.50 ns/op
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>BenchmarkNow/Depth28        		        96.53 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth29        		        94.81 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth30        		        92.30 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth31        	 	       246.70 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth32        	 	       255.40 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth33        	 	       269.50 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth36        	 	       267.80 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth37        	 	       276.70 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth38        	 	       310.40 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth39        	 	       307.20 ns/op
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>BenchmarkNow/Depth78        	 	       368.00 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth79        	 	       368.30 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth80        	 	       364.30 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth81        	 	       551.50 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth82        	 	       565.40 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth83        	 	       573.00 ns/op
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>BenchmarkNow/Depth97        	 	       624.90 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth98        	 	       640.00 ns/op
</span></span><span style=display:flex><span>BenchmarkNow/Depth99        	 	       649.90 ns/op
</span></span></code></pre></div><p>The cost of unwinding stack grows not linear. At some stack depths there are leaps. I believe they are caused by stack memory growing beyond different levels of memory caches.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>