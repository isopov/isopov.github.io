<!doctype html><html lang=en><head><title>Updating value in cache or simply invalidate it instead · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Recently I worked on a process of updating many entities in DB. And since these entities are read really often, there was a Redis-based cache in front of DB. After updating the entity in DB it was updated in the cache. And to be safe the whole process was under Redsic-based lock. So:
Lock for the entity is taken in Redis Entity is updated in DB Entity is updated in Redis Lost is released in Redis Everything is good and data is consistent everywhere, but this process is too long."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Updating value in cache or simply invalidate it instead"><meta name=twitter:description content="Recently I worked on a process of updating many entities in DB. And since these entities are read really often, there was a Redis-based cache in front of DB. After updating the entity in DB it was updated in the cache. And to be safe the whole process was under Redsic-based lock. So:
Lock for the entity is taken in Redis Entity is updated in DB Entity is updated in Redis Lost is released in Redis Everything is good and data is consistent everywhere, but this process is too long."><meta property="og:title" content="Updating value in cache or simply invalidate it instead"><meta property="og:description" content="Recently I worked on a process of updating many entities in DB. And since these entities are read really often, there was a Redis-based cache in front of DB. After updating the entity in DB it was updated in the cache. And to be safe the whole process was under Redsic-based lock. So:
Lock for the entity is taken in Redis Entity is updated in DB Entity is updated in Redis Lost is released in Redis Everything is good and data is consistent everywhere, but this process is too long."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/cache-update-or-invalidate/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-04T10:51:48+03:00"><meta property="article:modified_time" content="2020-11-04T10:51:48+03:00"><link rel=canonical href=https://isopov.github.io/posts/cache-update-or-invalidate/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/cache-update-or-invalidate/>Updating value in cache or simply invalidate it instead</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-11-04T10:51:48+03:00>November 4, 2020
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div class=post-content><p>Recently I worked on a process of updating many entities in DB. And since these entities are read really often, there was a Redis-based cache in front of DB. After updating the entity in DB it was updated in the cache. And to be safe the whole process was under Redsic-based lock. So:</p><ul><li>Lock for the entity is taken in Redis</li><li>Entity is updated in DB</li><li>Entity is updated in Redis</li><li>Lost is released in Redis</li></ul><p>Everything is good and data is consistent everywhere, but this process is too long. Lock acquire and release are the longest steps. But if we simply remove the locks data may become inconsistent between the DB and Redis. To craft such a sample is a too big task for a blog post, but a very similar concept can be recreated with any technology and at any level. In Java, there is <a href=https://github.com/openjdk/jcstress class=external-link target=_blank rel=noopener>Jcstress</a> - an excellent tool to dive into concurrency problems. Let&rsquo;s create a sample with it:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import org.openjdk.jcstress.annotations.*;
</span></span><span style=display:flex><span>import org.openjdk.jcstress.infra.results.Z_Result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import java.util.Map;
</span></span><span style=display:flex><span>import java.util.concurrent.ConcurrentHashMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@JCStressTest
</span></span><span style=display:flex><span>@Outcome(id = &#34;true&#34;, expect = Expect.ACCEPTABLE, desc = &#34;Cached value is equal to actual&#34;)
</span></span><span style=display:flex><span>@Outcome(expect = Expect.FORBIDDEN, desc = &#34;Value in cache differs from actual&#34;)
</span></span><span style=display:flex><span>@State
</span></span><span style=display:flex><span>public class CacheUpdateTest {
</span></span><span style=display:flex><span>    private static final Object KEY = new Object();
</span></span><span style=display:flex><span>    private volatile Object value;
</span></span><span style=display:flex><span>    private final Map&lt;Object, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Actor
</span></span><span style=display:flex><span>    public void set1() {
</span></span><span style=display:flex><span>        value = new Object();
</span></span><span style=display:flex><span>        cache.put(KEY, value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Actor
</span></span><span style=display:flex><span>    public void set2() {
</span></span><span style=display:flex><span>        value = new Object();
</span></span><span style=display:flex><span>        cache.put(KEY, value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Arbiter
</span></span><span style=display:flex><span>    public void arbiter(Z_Result r) {
</span></span><span style=display:flex><span>        r.r1 = value == cache.get(KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>No DB, no Redis, but both have their counterparts in this sample. Simple volatile variable to hold a single value. And ConcurrentHashMap to serve as a cache. Running this sample produces the following:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>*** FAILED tests
</span></span><span style=display:flex><span>  Strong asserts were violated. Correct implementations should have no assert failures here.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  4 matching test results. 
</span></span><span style=display:flex><span>  [FAILED] com.sopovs.moradanen.jcstress.CacheUpdateTest
</span></span><span style=display:flex><span>    (JVM args: [-XX:-TieredCompilation, -XX:+StressLCM, -XX:+StressGCM])
</span></span><span style=display:flex><span>  Observed state   Occurrences   Expectation  Interpretation                                              
</span></span><span style=display:flex><span>           false       391,352     FORBIDDEN  Value in cache differs from actual                          
</span></span><span style=display:flex><span>            true    23,479,779    ACCEPTABLE  Cached value is equal to actual                             
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [FAILED] com.sopovs.moradanen.jcstress.CacheUpdateTest
</span></span><span style=display:flex><span>    (JVM args: [-XX:-TieredCompilation])
</span></span><span style=display:flex><span>  Observed state   Occurrences   Expectation  Interpretation                                              
</span></span><span style=display:flex><span>           false       404,027     FORBIDDEN  Value in cache differs from actual                          
</span></span><span style=display:flex><span>            true    26,152,354    ACCEPTABLE  Cached value is equal to actual                             
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [FAILED] com.sopovs.moradanen.jcstress.CacheUpdateTest
</span></span><span style=display:flex><span>    (JVM args: [-XX:TieredStopAtLevel=1])
</span></span><span style=display:flex><span>  Observed state   Occurrences   Expectation  Interpretation                                              
</span></span><span style=display:flex><span>           false       379,522     FORBIDDEN  Value in cache differs from actual                          
</span></span><span style=display:flex><span>            true    21,681,059    ACCEPTABLE  Cached value is equal to actual                             
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [FAILED] com.sopovs.moradanen.jcstress.CacheUpdateTest
</span></span><span style=display:flex><span>    (JVM args: [-Xint])
</span></span><span style=display:flex><span>  Observed state   Occurrences   Expectation  Interpretation                                              
</span></span><span style=display:flex><span>           false        53,317     FORBIDDEN  Value in cache differs from actual                          
</span></span><span style=display:flex><span>            true     2,087,904    ACCEPTABLE  Cached value is equal to actual 
</span></span></code></pre></div><p>After updating the value and cache concurrently with two different values we may trap into inconsistency between the cache and final value. Is the lock the only way to solve this problem? Actually, not. Updating the value in cache is not a usual pattern, to begin with. Usually, we request values from the cache and some underlying machinery emits a request to DB if there is no cached value. And we can make sure that the next such query will get the right answer after updating the value in DB - simply remove the value from the cache. It has another benefit - if no one will ever request the value from cache - it will not be put there and will not waste resources.
Let&rsquo;s write this down:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import org.openjdk.jcstress.annotations.*;
</span></span><span style=display:flex><span>import org.openjdk.jcstress.infra.results.Z_Result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import java.util.Map;
</span></span><span style=display:flex><span>import java.util.concurrent.ConcurrentHashMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@JCStressTest
</span></span><span style=display:flex><span>@Outcome(id = &#34;true&#34;, expect = Expect.ACCEPTABLE, desc = &#34;Cached value is equal to actual&#34;)
</span></span><span style=display:flex><span>@Outcome(expect = Expect.FORBIDDEN, desc = &#34;Value in cache differs from actual&#34;)
</span></span><span style=display:flex><span>@State
</span></span><span style=display:flex><span>public class CacheInvalidateTest {
</span></span><span style=display:flex><span>    private static final Object KEY = new Object();
</span></span><span style=display:flex><span>    private volatile Object value;
</span></span><span style=display:flex><span>    private final Map&lt;Object, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private Object getValue() {
</span></span><span style=display:flex><span>        return cache.computeIfAbsent(KEY, o -&gt; value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Actor
</span></span><span style=display:flex><span>    public void set1() {
</span></span><span style=display:flex><span>        value = new Object();
</span></span><span style=display:flex><span>        cache.remove(KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Actor
</span></span><span style=display:flex><span>    public void set2() {
</span></span><span style=display:flex><span>        value = new Object();
</span></span><span style=display:flex><span>        cache.remove(KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Arbiter
</span></span><span style=display:flex><span>    public void arbiter(Z_Result r) {
</span></span><span style=display:flex><span>        r.r1 = value == getValue();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code passes all the tests. However, without removals, it will pass too. The only cache retrieval is happening in the check phase. To test a bit more we can add more actors like this:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>    @Actor
</span></span><span style=display:flex><span>    public void getValue1() {
</span></span><span style=display:flex><span>        getValue();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With them, tests pass too.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>