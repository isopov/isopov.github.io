<!doctype html><html lang=en><head><title>Go concurrent sort of the same slice · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Recently I&rsquo;ve stumbled upon a broken cache in my application written in Go. Some slices of structs got from database were
cached in memory. In the hindsight the problem is obvious - every consumer of this cache sorted these slices independently.
And since slices were cached in some cases they were sorting one and the same slice concurrently. Someone may suggest that
sorting should be done in the database with sort by, but even in the simplest case where it can be done on this level simply
adding SORT BY clause it may be not desirable. Usually application layer is scaled much easier than the storage layer.
Only some newest databases introduce their own scalable computational nodes separate from the storage nodes. Traditionally
you may want to make your queries as lightweight as possible and move some CPU-bound postprocessing to application layer.
Also, you don&rsquo;t want to query your database for one and the same information over and over. So caches are introduced to the
application layer. And here we go with DAO -> Cache -> Provider/Manager."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go concurrent sort of the same slice"><meta name=twitter:description content="Recently I’ve stumbled upon a broken cache in my application written in Go. Some slices of structs got from database were cached in memory. In the hindsight the problem is obvious - every consumer of this cache sorted these slices independently. And since slices were cached in some cases they were sorting one and the same slice concurrently. Someone may suggest that sorting should be done in the database with sort by, but even in the simplest case where it can be done on this level simply adding SORT BY clause it may be not desirable. Usually application layer is scaled much easier than the storage layer. Only some newest databases introduce their own scalable computational nodes separate from the storage nodes. Traditionally you may want to make your queries as lightweight as possible and move some CPU-bound postprocessing to application layer. Also, you don’t want to query your database for one and the same information over and over. So caches are introduced to the application layer. And here we go with DAO -> Cache -> Provider/Manager."><meta property="og:url" content="https://isopov.github.io/posts/go-concurrent-sort/"><meta property="og:site_name" content="isopov"><meta property="og:title" content="Go concurrent sort of the same slice"><meta property="og:description" content="Recently I’ve stumbled upon a broken cache in my application written in Go. Some slices of structs got from database were cached in memory. In the hindsight the problem is obvious - every consumer of this cache sorted these slices independently. And since slices were cached in some cases they were sorting one and the same slice concurrently. Someone may suggest that sorting should be done in the database with sort by, but even in the simplest case where it can be done on this level simply adding SORT BY clause it may be not desirable. Usually application layer is scaled much easier than the storage layer. Only some newest databases introduce their own scalable computational nodes separate from the storage nodes. Traditionally you may want to make your queries as lightweight as possible and move some CPU-bound postprocessing to application layer. Also, you don’t want to query your database for one and the same information over and over. So caches are introduced to the application layer. And here we go with DAO -> Cache -> Provider/Manager."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-05T11:55:49+03:00"><meta property="article:modified_time" content="2024-08-05T11:55:49+03:00"><meta property="article:tag" content="Golang"><link rel=canonical href=https://isopov.github.io/posts/go-concurrent-sort/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.38c4552ac40f9ae3408bad40358f654ebd8804412fe74ed56f2d6c8a7af82dd3.css integrity="sha256-OMRVKsQPmuNAi61ANY9lTr2IBEEv507Vby1sinr4LdM=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://isopov.github.io/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/go-concurrent-sort/>Go concurrent sort of the same slice</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-08-05T11:55:49+03:00>August 5, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/golang/>Golang</a></span></div></div></header><div class=post-content><p>Recently I&rsquo;ve stumbled upon a broken cache in my application written in Go. Some slices of structs got from database were
cached in memory. In the hindsight the problem is obvious - every consumer of this cache sorted these slices independently.
And since slices were cached in some cases they were sorting one and the same slice concurrently. Someone may suggest that
sorting should be done in the database with sort by, but even in the simplest case where it can be done on this level simply
adding <code>SORT BY</code> clause it may be not desirable. Usually application layer is scaled much easier than the storage layer.
Only some newest databases introduce their own scalable computational nodes separate from the storage nodes. Traditionally
you may want to make your queries as lightweight as possible and move some CPU-bound postprocessing to application layer.
Also, you don&rsquo;t want to query your database for one and the same information over and over. So caches are introduced to the
application layer. And here we go with DAO -> Cache -> Provider/Manager.</p><p>Here is the code that emulates this concurrent sorting of one and the same slice without database and cache layers.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;math/rand/v2&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0ff;font-weight:700>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> size = <span style=color:#ff0;font-weight:700>100</span>
</span></span><span style=display:flex><span>	s := <span style=color:#fff;font-weight:700>make</span>([]<span style=color:#fff;font-weight:700>int</span>, size)
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; size; i++ {
</span></span><span style=display:flex><span>		s[i] = i
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	rand.Shuffle(size, <span style=color:#fff;font-weight:700>func</span>(i, j <span style=color:#fff;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>		s[i], s[j] = s[j], s[i]
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	start := sync.WaitGroup{}
</span></span><span style=display:flex><span>	start.Add(<span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> goroutines = <span style=color:#ff0;font-weight:700>10</span>
</span></span><span style=display:flex><span>	end := sync.WaitGroup{}
</span></span><span style=display:flex><span>	end.Add(goroutines)
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; goroutines; i++ {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>go</span> <span style=color:#fff;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			start.Wait()
</span></span><span style=display:flex><span>			sort.Slice(s, <span style=color:#fff;font-weight:700>func</span>(i, j <span style=color:#fff;font-weight:700>int</span>) <span style=color:#fff;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>				<span style=color:#fff;font-weight:700>return</span> s[i] &lt; s[j]
</span></span><span style=display:flex><span>			})
</span></span><span style=display:flex><span>			end.Done()
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	start.Done()
</span></span><span style=display:flex><span>	end.Wait()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	incorrect := <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; size; i++ {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>if</span> s[i] != i {
</span></span><span style=display:flex><span>			fmt.Printf(<span style=color:#0ff;font-weight:700>&#34;%d instead of %d\n&#34;</span>, s[i], i)
</span></span><span style=display:flex><span>			incorrect++
</span></span><span style=display:flex><span>			<span style=color:#fff;font-weight:700>if</span> incorrect &gt; <span style=color:#ff0;font-weight:700>10</span> {
</span></span><span style=display:flex><span>				<span style=color:#fff;font-weight:700>return</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the results:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1 instead of 0
</span></span><span style=display:flex><span>5 instead of 1
</span></span><span style=display:flex><span>5 instead of 2
</span></span><span style=display:flex><span>5 instead of 3
</span></span><span style=display:flex><span>6 instead of 4
</span></span><span style=display:flex><span>6 instead of 5
</span></span><span style=display:flex><span>6 instead of 7
</span></span><span style=display:flex><span>7 instead of 8
</span></span><span style=display:flex><span>13 instead of 11
</span></span><span style=display:flex><span>14 instead of 12
</span></span><span style=display:flex><span>14 instead of 13
</span></span></code></pre></div><p>As you can see not only some elements of the slice are in the wrong places after this sort, but they are duplicated. This
problem is easily solved moving the sort below the cache and returning already sorted slice from the cache. Not that easy
solution is making the cached value immutable - you cannot simply get slices from the cache in this case.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>