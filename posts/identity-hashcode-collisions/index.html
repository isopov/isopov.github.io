<!doctype html><html lang=en><head><title>Collisions of hashcodes - much more real than an md5 collision · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="So okay, hashcode is int and so there are only 4294967296 distinct hashcodes. It is not a little number, but in modern systems there could be definitely much more objects.
In a very good book by Joshua Bloch I have read that there is a probability that two consequently created objects will have an equal system identity hashcode. Actually from the time of publishing that book major version of Java was released and the situation has improved dramatically."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Collisions of hashcodes - much more real than an md5 collision"><meta name=twitter:description content="So okay, hashcode is int and so there are only 4294967296 distinct hashcodes. It is not a little number, but in modern systems there could be definitely much more objects.
In a very good book by Joshua Bloch I have read that there is a probability that two consequently created objects will have an equal system identity hashcode. Actually from the time of publishing that book major version of Java was released and the situation has improved dramatically."><meta property="og:url" content="https://isopov.github.io/posts/identity-hashcode-collisions/"><meta property="og:site_name" content="isopov"><meta property="og:title" content="Collisions of hashcodes - much more real than an md5 collision"><meta property="og:description" content="So okay, hashcode is int and so there are only 4294967296 distinct hashcodes. It is not a little number, but in modern systems there could be definitely much more objects.
In a very good book by Joshua Bloch I have read that there is a probability that two consequently created objects will have an equal system identity hashcode. Actually from the time of publishing that book major version of Java was released and the situation has improved dramatically."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-03-26T10:19:24+03:00"><meta property="article:modified_time" content="2011-03-26T10:19:24+03:00"><meta property="article:tag" content="Java"><link rel=canonical href=https://isopov.github.io/posts/identity-hashcode-collisions/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/identity-hashcode-collisions/>Collisions of hashcodes - much more real than an md5 collision</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2011-03-26T10:19:24+03:00>March 26, 2011
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div class=post-content><p>So okay, hashcode is int and so there are only 4294967296 distinct hashcodes. It is not a little number, but in modern systems there could be definitely much more objects.</p><p>In a <a href=http://www.javapuzzlers.com/ class=external-link target=_blank rel=noopener>very good book</a> by Joshua Bloch I have read that there is a probability that two consequently created objects will have an equal system identity hashcode. Actually from the time of publishing that book major version of Java was released and the situation has improved dramatically. But still 232 is a very little number for objects. And still two consequently created objects may have an equal identity hashcode:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  private static final int SIZE = 500000000;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  public static void main(String[] args) {
</span></span><span style=display:flex><span>    int count = 0;
</span></span><span style=display:flex><span>    for (int i = 0; i &lt; SIZE; i++) {
</span></span><span style=display:flex><span>      if (new Object().hashCode() == new Object().hashCode()) {
</span></span><span style=display:flex><span>        count++;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.out.println(count + &#34; of &#34; + SIZE + &#34; consequently created pairs of objects had equal hashcodes&#34;);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>On my machine that produced the following output:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>16 of 500000000 consequently created objects had equal hashcodes
</span></span></code></pre></div><p>But creating objects and leaving them for garbage collection is not the usual way to deal with. At least for those objects for that we are worried about hashcodes and their quality. So here is the small test on how often the hashcodes will be collisional in a reasonably large pool of objects (The pool of 5000000 millions was chosen as it near to the size that can be checked on 32 bit JVM - actually running this program involves setting not standard size for the Java heap).</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  private static final int SIZE = 50000000;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  public static void main(String[] args) {
</span></span><span style=display:flex><span>    //number of objects with the same hashcode for each collisionall hashcode
</span></span><span style=display:flex><span>    Map&lt;Integer, Integer&gt; hashcodesMap = new HashMap&lt;Integer, Integer&gt;(SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    for (int i = 0; i &lt; SIZE; i++) {
</span></span><span style=display:flex><span>      int hashCode = (new Object()).hashCode();
</span></span><span style=display:flex><span>      Integer integer = hashcodesMap.get(hashCode);
</span></span><span style=display:flex><span>      if (integer == null) {
</span></span><span style=display:flex><span>        hashcodesMap.put(hashCode, 1);
</span></span><span style=display:flex><span>      } else {
</span></span><span style=display:flex><span>        hashcodesMap.put(hashCode, integer + 1);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Map&lt;Integer, Integer&gt; collisionsFrequency = new HashMap&lt;Integer, Integer&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    for (Integer value : hashcodesMap.values()) {
</span></span><span style=display:flex><span>      if (value &gt; 1) {
</span></span><span style=display:flex><span>        Integer integer = collisionsFrequency.get(value);
</span></span><span style=display:flex><span>        if (integer != null) {
</span></span><span style=display:flex><span>          collisionsFrequency.put(value, integer + 1);
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>          collisionsFrequency.put(value, 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    int totalCollisionObjects = 0;
</span></span><span style=display:flex><span>    for (Entry&lt;Integer, Integer&gt; entry : collisionsFrequency.entrySet()) {
</span></span><span style=display:flex><span>      totalCollisionObjects += entry.getValue() * entry.getKey();
</span></span><span style=display:flex><span>      System.out.println(entry.getValue() + &#34; hashcodes with &#34; + entry.getKey() + &#34; objects per each&#34;);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.out.println(&#34;&#34;);
</span></span><span style=display:flex><span>    System.out.println(&#34;Only &#34; + (SIZE - totalCollisionObjects) + &#34; among &#34; + SIZE + &#34; have unique hashcode&#34;);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>This code produced the following output on my machine:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>8509145 hashcodes with 2 objects per each
</span></span><span style=display:flex><span>4195283 hashcodes with 3 objects per each
</span></span><span style=display:flex><span>1523953 hashcodes with 4 objects per each
</span></span><span style=display:flex><span>435035 hashcodes with 5 objects per each
</span></span><span style=display:flex><span>102849 hashcodes with 6 objects per each
</span></span><span style=display:flex><span>20149 hashcodes with 7 objects per each
</span></span><span style=display:flex><span>3455 hashcodes with 8 objects per each
</span></span><span style=display:flex><span>506 hashcodes with 9 objects per each
</span></span><span style=display:flex><span>72 hashcodes with 10 objects per each
</span></span><span style=display:flex><span>9 hashcodes with 11 objects per each
</span></span><span style=display:flex><span>1 hashcodes with 12 objects per each
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Only 11333712 among 50000000 have unique hashcode
</span></span></code></pre></div><p>So the major portion of used identity hashcodes are collisional. And with that less than a percent of possible unique values of int was used. With less objects in out pool the result is better:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>317898 hashcodes with 2 objects per each
</span></span><span style=display:flex><span>15295 hashcodes with 3 objects per each
</span></span><span style=display:flex><span>524 hashcodes with 4 objects per each
</span></span><span style=display:flex><span>13 hashcodes with 5 objects per each
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Only 4316158 among 5000000 have unique hashcode
</span></span></code></pre></div><p>Actually all this is not very impressive and leads to the one major consequence:
Writing:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  @Override
</span></span><span style=display:flex><span>  public boolean equals(Object obj) {
</span></span><span style=display:flex><span>    return System.identityHashCode(this) == System.identityHashCode(obj);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>is a really bad idea. And yes, I saw this (not exactly this, there were at least null-check in that method&mldr;).</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>