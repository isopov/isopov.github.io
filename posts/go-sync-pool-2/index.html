<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="I&rsquo;ve posted my brief experiments with sync.Pool in go. However, reading about it guides that it may be hard to use tool. And sometimes it can degrade for third-party reasons. It is easy to trap into old information regarding sync.Pool and gc interrogation. Since go 1.13 sync.Pool is not cleared completely on every gc. However, it is still affected by gc. Suppose the following code:
type Obj []int func (o *Obj) Fill() { for i := 0; i < cap(*o); i++ { *o = append(*o, i) } } func (o Obj) Count() int { result := 0 for i := 0; i < len(o); i++ { result += o[i] } return result } func NewObj() *Obj { o := make(Obj, 0, 100*1024) return &amp;o } var objPool = &amp;sync."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go sync.Pool and gc"><meta name=twitter:description content="I&rsquo;ve posted my brief experiments with sync.Pool in go. However, reading about it guides that it may be hard to use tool. And sometimes it can degrade for third-party reasons. It is easy to trap into old information regarding sync.Pool and gc interrogation. Since go 1.13 sync.Pool is not cleared completely on every gc. However, it is still affected by gc. Suppose the following code:
type Obj []int func (o *Obj) Fill() { for i := 0; i < cap(*o); i++ { *o = append(*o, i) } } func (o Obj) Count() int { result := 0 for i := 0; i < len(o); i++ { result += o[i] } return result } func NewObj() *Obj { o := make(Obj, 0, 100*1024) return &amp;o } var objPool = &amp;sync."><meta property="og:title" content="Go sync.Pool and gc"><meta property="og:description" content="I&rsquo;ve posted my brief experiments with sync.Pool in go. However, reading about it guides that it may be hard to use tool. And sometimes it can degrade for third-party reasons. It is easy to trap into old information regarding sync.Pool and gc interrogation. Since go 1.13 sync.Pool is not cleared completely on every gc. However, it is still affected by gc. Suppose the following code:
type Obj []int func (o *Obj) Fill() { for i := 0; i < cap(*o); i++ { *o = append(*o, i) } } func (o Obj) Count() int { result := 0 for i := 0; i < len(o); i++ { result += o[i] } return result } func NewObj() *Obj { o := make(Obj, 0, 100*1024) return &amp;o } var objPool = &amp;sync."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/go-sync-pool-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-01T13:10:49+03:00"><meta property="article:modified_time" content="2022-03-01T13:10:49+03:00"><title>Go sync.Pool and gc · isopov</title><link rel=canonical href=https://isopov.github.io/posts/go-sync-pool-2/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.119.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/go-sync-pool-2/>Go sync.Pool and gc</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-03-01T13:10:49+03:00>March 1, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/golang/>Golang</a></span></div></div></header><div><p>I&rsquo;ve posted my brief experiments with sync.Pool in go. However, reading about it guides that it may be hard to use tool. And sometimes it can degrade for third-party reasons.
It is easy to trap into old information regarding sync.Pool and gc interrogation. <a href=https://github.com/golang/go/commit/2dcbf8b3691e72d1b04e9376488cef3b6f93b286>Since go 1.13 sync.Pool is not cleared completely on every gc</a>. However, it is still affected by gc. Suppose the following code:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>type</span> Obj []<span style=color:#fff;font-weight:700>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> (o *Obj) Fill() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#fff;font-weight:700>cap</span>(*o); i++ {
</span></span><span style=display:flex><span>		*o = <span style=color:#fff;font-weight:700>append</span>(*o, i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> (o Obj) Count() <span style=color:#fff;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	result := <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#fff;font-weight:700>len</span>(o); i++ {
</span></span><span style=display:flex><span>		result += o[i]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> NewObj() *Obj {
</span></span><span style=display:flex><span>	o := <span style=color:#fff;font-weight:700>make</span>(Obj, <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>100</span>*<span style=color:#ff0;font-weight:700>1024</span>)
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> &amp;o
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> objPool = &amp;sync.Pool{
</span></span><span style=display:flex><span>	New: <span style=color:#fff;font-weight:700>func</span>() <span style=color:#fff;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>return</span> NewObj()
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> ResultTrap <span style=color:#fff;font-weight:700>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> WorkWithPool() {
</span></span><span style=display:flex><span>	o := objPool.Get().(*Obj)
</span></span><span style=display:flex><span>	o.Fill()
</span></span><span style=display:flex><span>	ResultTrap = o.Count()
</span></span><span style=display:flex><span>	released := (*o)[:<span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>	objPool.Put(&amp;released)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And let&rsquo;s use it this way:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>func</span> BenchmarkPool(b *testing.B) {
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;OnlyGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;NoGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			WorkWithPool()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;OneGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			WorkWithPool()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;TwoGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			WorkWithPool()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;ThreeGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			WorkWithPool()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	b.Run(<span style=color:#0ff;font-weight:700>&#34;FourGC&#34;</span>, <span style=color:#fff;font-weight:700>func</span>(b *testing.B) {
</span></span><span style=display:flex><span>		b.ReportAllocs()
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>for</span> i := <span style=color:#ff0;font-weight:700>0</span>; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>			WorkWithPool()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>			runtime.GC()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here are the results:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>BenchmarkPool
</span></span><span style=display:flex><span>BenchmarkPool/OnlyGC
</span></span><span style=display:flex><span>BenchmarkPool/OnlyGC-8         	   69956	    149475 ns/op	      13 B/op	       0 allocs/op
</span></span><span style=display:flex><span>BenchmarkPool/NoGC
</span></span><span style=display:flex><span>BenchmarkPool/NoGC-8           	   50950	    225802 ns/op	      40 B/op	       1 allocs/op
</span></span><span style=display:flex><span>BenchmarkPool/OneGC
</span></span><span style=display:flex><span>BenchmarkPool/OneGC-8          	   29601	    405608 ns/op	  495570 B/op	       4 allocs/op
</span></span><span style=display:flex><span>BenchmarkPool/TwoGC
</span></span><span style=display:flex><span>BenchmarkPool/TwoGC-8          	   19710	    612537 ns/op	  820298 B/op	       5 allocs/op
</span></span><span style=display:flex><span>BenchmarkPool/ThreeGC
</span></span><span style=display:flex><span>BenchmarkPool/ThreeGC-8        	   15132	    806346 ns/op	  820312 B/op	       5 allocs/op
</span></span><span style=display:flex><span>BenchmarkPool/FourGC
</span></span><span style=display:flex><span>BenchmarkPool/FourGC-8         	   12048	   1012356 ns/op	  820327 B/op	       5 allocs/op
</span></span></code></pre></div><p>Even one garbage collection hugely affects allocations of this test. Two garbage collections affect it even more, while any additionals have no effect. Suppose you have some near zero-allocating application that uses sync.Pools heavily in various places. Any change leading to memory allocation big enough for garbage collection happening may lead to
cascading failure of protection from allocations and hiding the original cause of the allocation spike.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2023
Ivan Sopov
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js integrity="sha256-nPLb+baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script></body></html>