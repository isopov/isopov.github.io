<!doctype html><html lang=en><head><title>ForkJoin factorial · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Several months ago I wrote a multithreaded factorial method. It was very simple from the point of view of the underlying technology, but not so trivial from the point of view of synchronizing threads. It used simple start() and join() methods that are available since the Java 1.0 And than I thought that with all the power of java I can improve it. So i used the ThreadPoolExecutor - a piece of technology from the Java 5 and really improved - here is my post about multithreaded factorial using TreadPoolExecutor."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="ForkJoin factorial"><meta name=twitter:description content="Several months ago I wrote a multithreaded factorial method. It was very simple from the point of view of the underlying technology, but not so trivial from the point of view of synchronizing threads. It used simple start() and join() methods that are available since the Java 1.0 And than I thought that with all the power of java I can improve it. So i used the ThreadPoolExecutor - a piece of technology from the Java 5 and really improved - here is my post about multithreaded factorial using TreadPoolExecutor."><meta property="og:title" content="ForkJoin factorial"><meta property="og:description" content="Several months ago I wrote a multithreaded factorial method. It was very simple from the point of view of the underlying technology, but not so trivial from the point of view of synchronizing threads. It used simple start() and join() methods that are available since the Java 1.0 And than I thought that with all the power of java I can improve it. So i used the ThreadPoolExecutor - a piece of technology from the Java 5 and really improved - here is my post about multithreaded factorial using TreadPoolExecutor."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/forkjoin-factorial/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-10-09T10:05:54+03:00"><meta property="article:modified_time" content="2011-10-09T10:05:54+03:00"><link rel=canonical href=https://isopov.github.io/posts/forkjoin-factorial/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/forkjoin-factorial/>ForkJoin factorial</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2011-10-09T10:05:54+03:00>October 9, 2011
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div class=post-content><p>Several months ago I wrote a <a href=https://isopov.github.io/posts/multithreaded-factorial/>multithreaded factorial</a> method. It was very simple from the point of view of the underlying technology, but not so trivial from the point of view of synchronizing threads. It used simple start() and join() methods that are available since the Java 1.0 And than I thought that with all the power of java I can improve it. So i used the ThreadPoolExecutor - a piece of technology from the Java 5 and really improved - here is my post about <a href=https://isopov.github.io/posts/multithreaded-factorial-with-threadpoolexecutor/>multithreaded factorial using TreadPoolExecutor</a>.</p><p>But Java 5 is a bit old now. And this year the Java 7 has been released! So here is the new version - using the new ForkJoin Framework available in it. Actually when I started writing this simple piece of code is didn&rsquo;nt think that the result can be like that. I thought that all the power of my 4-core processor was already utilized by the variant with the ThreadPoolExecutor and considered this new method only as an exercise on the new API. I previewed that new version may be simpler as this is one of the stated goals of ForkJoin Framework and it is. But the actual performance increase was absolutely unforeseen by me.</p><p>So no more jabber, here are the results:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>21 seconds for ForkJoin
</span></span><span style=display:flex><span>27 seconds for ThreadPoolExecutor
</span></span></code></pre></div><p>Here is the code:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>    private <span style=color:#fff;font-weight:700>static</span> BigInteger factFjPool(int input, int numThreads)
</span></span><span style=display:flex><span>            throws InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        ForkJoinPool forkJoinPool = new ForkJoinPool(numThreads);
</span></span><span style=display:flex><span>        ForkJoinTask&lt;BigInteger&gt; future = forkJoinPool.submit(new FactorialRecursiveTask(<span style=color:#ff0;font-weight:700>1</span>, input + <span style=color:#ff0;font-weight:700>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> future.get();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private <span style=color:#fff;font-weight:700>static</span> <span style=color:#fff;font-weight:700>class</span> FactorialRecursiveTask <span style=color:#fff;font-weight:700>extends</span> RecursiveTask&lt;BigInteger&gt; {
</span></span><span style=display:flex><span>        private <span style=color:#fff;font-weight:700>static</span> final long serialVersionUID = <span style=color:#ff0;font-weight:700>1</span>L;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        private <span style=color:#fff;font-weight:700>static</span> final int THRESHOLD = <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        private final int lo, hi;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        public FactorialRecursiveTask(int lo, int hi) {
</span></span><span style=display:flex><span>            this.lo = lo;
</span></span><span style=display:flex><span>            this.hi = hi;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:red>@</span>Override
</span></span><span style=display:flex><span>        protected BigInteger compute() {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>if</span> (hi - lo &lt; THRESHOLD) {
</span></span><span style=display:flex><span>                BigInteger result = BigInteger.valueOf(lo);
</span></span><span style=display:flex><span>                <span style=color:#fff;font-weight:700>for</span> (int i = lo + <span style=color:#ff0;font-weight:700>1</span>; i &lt; hi; i++) {
</span></span><span style=display:flex><span>                    result = result.multiply(BigInteger.valueOf(i));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#fff;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>            } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>                int mid = (lo + hi) &gt;&gt;&gt; <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                FactorialRecursiveTask f1 = new FactorialRecursiveTask(lo, mid);
</span></span><span style=display:flex><span>                f1.fork();
</span></span><span style=display:flex><span>                FactorialRecursiveTask f2 = new FactorialRecursiveTask(mid, hi);
</span></span><span style=display:flex><span>                <span style=color:#fff;font-weight:700>return</span> f2.compute().multiply(f1.join());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>I&rsquo;ve tried to improve the previous version using other amount of threads, since this version obviously uses division into mush smaller sub-tasks, but to no result. Maybe I used wrong <code>BlockingQueue&lt;Runnable></code>, but this may be regarded as the simplicity of using this API. And definitely <code>ForkJoinFramework</code> is superior here, since not only decision about which Queue to use is not needed but also the division into sub-tasks is much simpler.</p><p>As usual the full code for this example may be found on <a href=https://gist.github.com/1272876 class=external-link target=_blank rel=noopener>github</a>.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>