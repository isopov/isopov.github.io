<!doctype html><html lang=en><head><title>Java GC, generational hypothesis and throughput Â· isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="In recent years Java and Hotspot JVM in particular received several new garbage collectors. Most recently generational Z collector was introduced.
It is common knowledge that it is possible to achieve almost any results in artificial benchmarks, but nonetheless it may be interesting to create them anyway.
@State(Scope.Thread) @Fork(value = 1, jvmArgs = {&#34;-Xmx100m&#34;}) @Warmup(iterations = 3, time = 1) @Measurement(iterations = 5, time = 1) public class GenerationsBenchmark { public static final int OBJECTS_1MB = 1024 * 1024 / 16; private ArrayList<Object> olds; @Param({&#34;0&#34;, &#34;20&#34;, &#34;40&#34;, &#34;60&#34;}) public int oldObjects; @Setup public void setup() { olds = new ArrayList<>(oldObjects * OBJECTS_1MB); for (int i = 0; i < oldObjects * OBJECTS_1MB; i++) { olds."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java GC, generational hypothesis and throughput"><meta name=twitter:description content="In recent years Java and Hotspot JVM in particular received several new garbage collectors. Most recently generational Z collector was introduced.
It is common knowledge that it is possible to achieve almost any results in artificial benchmarks, but nonetheless it may be interesting to create them anyway.
@State(Scope.Thread) @Fork(value = 1, jvmArgs = {&#34;-Xmx100m&#34;}) @Warmup(iterations = 3, time = 1) @Measurement(iterations = 5, time = 1) public class GenerationsBenchmark { public static final int OBJECTS_1MB = 1024 * 1024 / 16; private ArrayList<Object> olds; @Param({&#34;0&#34;, &#34;20&#34;, &#34;40&#34;, &#34;60&#34;}) public int oldObjects; @Setup public void setup() { olds = new ArrayList<>(oldObjects * OBJECTS_1MB); for (int i = 0; i < oldObjects * OBJECTS_1MB; i++) { olds."><meta property="og:title" content="Java GC, generational hypothesis and throughput"><meta property="og:description" content="In recent years Java and Hotspot JVM in particular received several new garbage collectors. Most recently generational Z collector was introduced.
It is common knowledge that it is possible to achieve almost any results in artificial benchmarks, but nonetheless it may be interesting to create them anyway.
@State(Scope.Thread) @Fork(value = 1, jvmArgs = {&#34;-Xmx100m&#34;}) @Warmup(iterations = 3, time = 1) @Measurement(iterations = 5, time = 1) public class GenerationsBenchmark { public static final int OBJECTS_1MB = 1024 * 1024 / 16; private ArrayList<Object> olds; @Param({&#34;0&#34;, &#34;20&#34;, &#34;40&#34;, &#34;60&#34;}) public int oldObjects; @Setup public void setup() { olds = new ArrayList<>(oldObjects * OBJECTS_1MB); for (int i = 0; i < oldObjects * OBJECTS_1MB; i++) { olds."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/java-gc-and-generations/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-30T15:10:49+03:00"><meta property="article:modified_time" content="2023-11-30T15:10:49+03:00"><link rel=canonical href=https://isopov.github.io/posts/java-gc-and-generations/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.135e22c97ff685fe983fc60048e309ced8f00d8d38f536aa67dba8a13a03dfa4.css integrity="sha256-E14iyX/2hf6YP8YASOMJztjwDY049TaqZ9uooToD36Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/java-gc-and-generations/>Java GC, generational hypothesis and throughput</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-11-30T15:10:49+03:00>November 30, 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div class=post-content><p>In recent years Java and Hotspot JVM in particular received several new garbage collectors. Most recently generational
Z collector <a href=https://inside.java/2023/11/28/gen-zgc-explainer/ class=external-link target=_blank rel=noopener>was introduced</a>.</p><p>It is common knowledge that it is possible to achieve almost any results in artificial benchmarks, but nonetheless it may
be interesting to create them anyway.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@State(Scope.<span style=color:#007f7f>Thread</span>)
</span></span><span style=display:flex><span>@Fork(value = 1, jvmArgs = {<span style=color:#0ff;font-weight:700>&#34;-Xmx100m&#34;</span>})
</span></span><span style=display:flex><span>@Warmup(iterations = 3, time = 1)
</span></span><span style=display:flex><span>@Measurement(iterations = 5, time = 1)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>class</span> GenerationsBenchmark {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>static</span> <span style=color:#fff;font-weight:700>final</span> <span style=color:#fff;font-weight:700>int</span> OBJECTS_1MB = 1024 * 1024 / 16;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> ArrayList&lt;Object&gt; olds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Param({<span style=color:#0ff;font-weight:700>&#34;0&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;20&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;40&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;60&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>int</span> oldObjects;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Setup
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> setup() {
</span></span><span style=display:flex><span>        olds = <span style=color:#fff;font-weight:700>new</span> ArrayList&lt;&gt;(oldObjects * OBJECTS_1MB);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = 0; i &lt; oldObjects * OBJECTS_1MB; i++) {
</span></span><span style=display:flex><span>            olds.<span style=color:#007f7f>add</span>(<span style=color:#fff;font-weight:700>new</span> Object());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseG1GC&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> g1(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>private</span> <span style=color:#fff;font-weight:700>static</span> <span style=color:#fff;font-weight:700>void</span> bench(Blackhole bh) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = 0; i &lt; OBJECTS_1MB; i++) {
</span></span><span style=display:flex><span>            bh.<span style=color:#007f7f>consume</span>(<span style=color:#fff;font-weight:700>new</span> Object());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>static</span> <span style=color:#fff;font-weight:700>void</span> main(String[] args) <span style=color:#fff;font-weight:700>throws</span> RunnerException {
</span></span><span style=display:flex><span>        Options opt = <span style=color:#fff;font-weight:700>new</span> OptionsBuilder().<span style=color:#007f7f>include</span>(<span style=color:#0ff;font-weight:700>&#34;.*&#34;</span> + GenerationsBenchmark.<span style=color:#007f7f>class</span>.<span style=color:#007f7f>getSimpleName</span>() + <span style=color:#0ff;font-weight:700>&#34;.*&#34;</span>).<span style=color:#007f7f>build</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>new</span> Runner(opt).<span style=color:#007f7f>run</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First of all this benchmark is flawed that it is run with 1 fork of each configuration only. But results are quite
stable and difference between configurations is so large, that we may save the time. Also, 100 MB of heap is not a
common size for modern application, so this bench is truly artificial and micro. Some garbage collectors are not
suited for such a small heap, while the others are optimized for this extreme too. So the comparison is not fair at all.
Any judgments based on it should be applicable only in a similar very unusual situation.</p><p>Besides small heap of 100MB various amounts of it are occupied by always referenced objects. In different runs the
total amount of such objects varies between 0 and 60MB (or even slightly more acounting for ArrayList referencing them).</p><p>But having said all of the above here are the results.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Benchmark                       (oldObjects)   Mode  Cnt      Score     Error  Units
</span></span><span style=display:flex><span>GenerationsBenchmark.g1                    0  thrpt    5  12434.452 Â±  80.775  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.g1                   20  thrpt    5  12415.055 Â± 167.382  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.g1                   40  thrpt    5  11219.861 Â± 165.378  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.g1                   60  thrpt    5   9816.738 Â± 962.618  ops/s
</span></span></code></pre></div><p>G1 has been the default garbage collector for many years by now. We may consider its results as reference. But since our
test is measuring throughput lets see the results of throughput optimized collector - Parallel. Here is the test for it.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseParallelGC&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> parallelDefault(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With the results.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.parallelDefault       0  thrpt    5  12712.576 Â± 144.766  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallelDefault      20  thrpt    5  10652.029 Â± 210.238  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallelDefault      40  thrpt    5    411.664 Â±  30.261  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallelDefault      60  thrpt    5    180.962 Â±  12.367  ops/s
</span></span></code></pre></div><p>They are a bit disappointing since it cannot deal with large enough old heap region&mldr; But the total heap is too small
for Parallel collector - lets try Serial that should be basically the same, but without multiple threads overhead.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseSerialGC&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> serialDefault(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Results are:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.serialDefault         0  thrpt    5  13048.856 Â± 131.335  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serialDefault        20  thrpt    5  13023.243 Â± 266.766  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serialDefault        40  thrpt    5  13051.316 Â±  91.953  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serialDefault        60  thrpt    5    234.666 Â±   8.511  ops/s
</span></span></code></pre></div><p>It seems that young and old region sizes are different for Serial and Parallel collectors. What about trying to tune them
ourselves?</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseSerialGC&#34;</span>}, jvmArgsAppend = {<span style=color:#0ff;font-weight:700>&#34;-XX:NewSize=10m&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> serial10MBNew(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.serial10MBNew         0  thrpt    5  12547.985 Â±  67.592  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serial10MBNew        20  thrpt    5  12490.781 Â± 202.933  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serial10MBNew        40  thrpt    5  12273.471 Â± 109.860  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.serial10MBNew        60  thrpt    5  12186.136 Â± 382.122  ops/s
</span></span></code></pre></div><p>Throughput for the no or small old heap region decreased a bit, but we managed to get rid of tremendous regression in
the large old region case. I suppose G1 collector was capable of dealing in all these cases without manual tuning due to
its heap regions dynamically changing to belong to young or old generation. However, lets try to tune Parallel collector
in a similar way.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseParallelGC&#34;</span>}, jvmArgsAppend = {<span style=color:#0ff;font-weight:700>&#34;-XX:NewSize=10m&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> parallel10MBNew(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.parallel10MBNew       0  thrpt    5  11286.414 Â± 741.980  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallel10MBNew      20  thrpt    5   6177.843 Â± 663.973  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallel10MBNew      40  thrpt    5   4595.050 Â± 227.420  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.parallel10MBNew      60  thrpt    5   3869.422 Â± 138.329  ops/s
</span></span></code></pre></div><p>The results are much better than without manual tuning, but still degradation is tremendous. We should not use Parallel
gc with so small heap.</p><p>After these tests lets look at modern non-generational collectors.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseShenandoahGC&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> shenandoah(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.shenandoah            0  thrpt    5    288.230 Â± 135.077  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.shenandoah           20  thrpt    5    531.991 Â±  85.333  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.shenandoah           40  thrpt    5    394.158 Â±  44.923  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.shenandoah           60  thrpt    5    197.308 Â±  23.372  ops/s
</span></span></code></pre></div><p>As we can see Shenandoah is not suited for throughput oriented workloads with so small heaps.</p><p>How about Z garbage collector?</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseZGC&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> zgc(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.zgc                   0  thrpt    5   7753.977 Â± 275.895  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgc                  20  thrpt    5   1906.405 Â±  56.030  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgc                  40  thrpt    5    606.713 Â±   4.973  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgc                  60  thrpt    5     27.959 Â±   0.774  ops/s
</span></span></code></pre></div><p>Results are much better, though old objects in heap cause degradation. However, I have started my post with a link
to generational Z collector introduction, so lets see how it will deal with the task.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseZGC&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;-XX:+ZGenerational&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> zgcGen(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.zgcGen                0  thrpt    5  10271.648 Â± 308.686  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen               20  thrpt    5   7874.979 Â± 622.759  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen               40  thrpt    5   4300.210 Â± 367.747  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen               60  thrpt    5    481.354 Â±  94.315  ops/s
</span></span></code></pre></div><p>Definitely better and in degraded extreme case better than its direct competitor Shenandoah.</p><p>It seems that we can try manual tuning with generational Z collector as well.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    @Benchmark
</span></span><span style=display:flex><span>    @Fork(jvmArgsPrepend = {<span style=color:#0ff;font-weight:700>&#34;-XX:+UseZGC&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;-XX:+ZGenerational&#34;</span>}, jvmArgsAppend = {<span style=color:#0ff;font-weight:700>&#34;-XX:NewSize=10m&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>public</span> <span style=color:#fff;font-weight:700>void</span> zgcGen10MBNew(Blackhole bh) {
</span></span><span style=display:flex><span>        bench(bh);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GenerationsBenchmark.zgcGen10MBNew         0  thrpt    5  10362.045 Â± 484.911  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen10MBNew        20  thrpt    5   7856.814 Â± 488.436  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen10MBNew        40  thrpt    5   4400.990 Â± 292.039  ops/s
</span></span><span style=display:flex><span>GenerationsBenchmark.zgcGen10MBNew        60  thrpt    5    508.789 Â±  28.856  ops/s
</span></span></code></pre></div><p>Absolutely no difference. It seems that NewSize option specifies only start size of new generation heap region and it
will change after some iterations. Just like in G1 collector, but with not that level of success yet.</p><p>To sum up - in this non-realistic artificial case it is seen that default collector is the best since it does not need
any tuning options. And in my experience tuning options for GC are obsolete and do not reflect the modern needs of the
application. So I prefer to not tune anything and always question not only permgen size specified. (Note: in modern
Hotspot JVM there is no permgen so this configuration presence is a clear indicator that GC options need revisiting).</p><p>Though all the details and numbers should not be relied on, I must say on more thing - about my testing environment. I
run all the tests on M1Pro Macbook with these versions:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># JMH version: 1.36
</span></span><span style=display:flex><span># VM version: JDK 21.0.1, OpenJDK 64-Bit Server VM, 21.0.1+12-LTS
</span></span></code></pre></div></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2011 -
2023
Ivan Sopov
Â·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>