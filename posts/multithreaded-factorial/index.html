<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Update: the follow up post gives another version, that lacks the drawback of unequal load on processor cores.
There is a very good blog post about how to write the factorial method in Java (really it is not about righting factorial). However, even in this master peace;-) there is no multi-threaded factorial. So here it is. There are some problems with it. The most significant is that multiplying all the BigIntegers from 1 to 50000 is much less heavy job for the computer, than multiplying all BigIntegers from 50001 to 100000."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Multithreaded factorial"><meta name=twitter:description content="Update: the follow up post gives another version, that lacks the drawback of unequal load on processor cores.
There is a very good blog post about how to write the factorial method in Java (really it is not about righting factorial). However, even in this master peace;-) there is no multi-threaded factorial. So here it is. There are some problems with it. The most significant is that multiplying all the BigIntegers from 1 to 50000 is much less heavy job for the computer, than multiplying all BigIntegers from 50001 to 100000."><meta property="og:title" content="Multithreaded factorial"><meta property="og:description" content="Update: the follow up post gives another version, that lacks the drawback of unequal load on processor cores.
There is a very good blog post about how to write the factorial method in Java (really it is not about righting factorial). However, even in this master peace;-) there is no multi-threaded factorial. So here it is. There are some problems with it. The most significant is that multiplying all the BigIntegers from 1 to 50000 is much less heavy job for the computer, than multiplying all BigIntegers from 50001 to 100000."><meta property="og:type" content="article"><meta property="og:url" content="https://isopov.github.io/posts/multithreaded-factorial/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-07-03T09:55:51+03:00"><meta property="article:modified_time" content="2011-07-03T09:55:51+03:00"><title>Multithreaded factorial · isopov</title><link rel=canonical href=https://isopov.github.io/posts/multithreaded-factorial/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.119.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>isopov</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/multithreaded-factorial/>Multithreaded factorial</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2011-07-03T09:55:51+03:00>July 3, 2011</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div><p><strong>Update</strong>: <a href=https://isopov.github.io/posts/multithreaded-factorial-with-threadpoolexecutor/>the follow up post</a> gives another version, that lacks the drawback of unequal load on processor cores.</p><p>There is a very good blog post about <a href="https://chaosinmotion.com/blog/?p=622">how to write the factorial</a> method in Java (really it is not about righting factorial). However, even in this master peace;-) there is no multi-threaded factorial. So here it is.
There are some problems with it. The most significant is that multiplying all the BigIntegers from 1 to 50000 is much less heavy job for the computer, than multiplying all BigIntegers from 50001 to 100000. So the the amount of work that is done by each worker-thread is not equal. But investigation on how this may be resolved in a common way is much harder problem, than just writing what I am publishing here. Maybe I&rsquo;ll do it in the other post.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#fff;font-weight:700>package</span> sample;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> java.math.BigDecimal;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> java.util.concurrent.TimeUnit;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> junit.framework.Assert;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> org.junit.Test;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>public class FactorialTest {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private static final <span style=color:#fff;font-weight:700>int</span> INPUT = <span style=color:#ff0;font-weight:700>203457</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:red>@</span>Test
</span></span><span style=display:flex><span>    public void test() throws InterruptedException {
</span></span><span style=display:flex><span>        BigDecimal fact1, fact2;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            long start = System.nanoTime();
</span></span><span style=display:flex><span>            fact1 = fact(INPUT);
</span></span><span style=display:flex><span>            long end = System.nanoTime();
</span></span><span style=display:flex><span>            System.out.<span style=color:#fff;font-weight:700>println</span>(TimeUnit.SECONDS.convert(end - start,
</span></span><span style=display:flex><span>                    TimeUnit.NANOSECONDS) + <span style=color:#0ff;font-weight:700>&#34; seconds for 1 thread&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            long start = System.nanoTime();
</span></span><span style=display:flex><span>            fact2 = factMt(INPUT, <span style=color:#ff0;font-weight:700>4</span>);
</span></span><span style=display:flex><span>            long end = System.nanoTime();
</span></span><span style=display:flex><span>            System.out.<span style=color:#fff;font-weight:700>println</span>(TimeUnit.SECONDS.convert(end - start,
</span></span><span style=display:flex><span>                    TimeUnit.NANOSECONDS) + <span style=color:#0ff;font-weight:700>&#34; seconds for 4 threads&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Assert.assertEquals(fact1, fact2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private static BigDecimal fact(<span style=color:#fff;font-weight:700>int</span> input) {
</span></span><span style=display:flex><span>        BigDecimal result = BigDecimal.valueOf(<span style=color:#ff0;font-weight:700>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = <span style=color:#ff0;font-weight:700>1</span>; i &lt;= input; i++) {
</span></span><span style=display:flex><span>            result = result.multiply(BigDecimal.valueOf(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private static BigDecimal factMt(<span style=color:#fff;font-weight:700>int</span> input, <span style=color:#fff;font-weight:700>int</span> numThreads)
</span></span><span style=display:flex><span>            throws InterruptedException {
</span></span><span style=display:flex><span>        BigDecimal result = BigDecimal.valueOf(<span style=color:#ff0;font-weight:700>1</span>);
</span></span><span style=display:flex><span>        Thread[] threads = new Thread[numThreads];
</span></span><span style=display:flex><span>        FactComputer[] workers = new FactComputer[numThreads];
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = <span style=color:#ff0;font-weight:700>1</span>; i &lt;= numThreads; i++) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>int</span> start = i == <span style=color:#ff0;font-weight:700>1</span> <span style=color:red>?</span> <span style=color:#ff0;font-weight:700>1</span> : (input / numThreads * (i - <span style=color:#ff0;font-weight:700>1</span>)) + <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>int</span> end = i == numThreads <span style=color:red>?</span> input : input / numThreads * i;
</span></span><span style=display:flex><span>            workers[i - <span style=color:#ff0;font-weight:700>1</span>] = new FactComputer(start, end);
</span></span><span style=display:flex><span>            threads[i - <span style=color:#ff0;font-weight:700>1</span>] = new Thread(workers[i - <span style=color:#ff0;font-weight:700>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; numThreads; i++) {
</span></span><span style=display:flex><span>            threads[i].start();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; numThreads; i++) {
</span></span><span style=display:flex><span>            threads[i].join();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; numThreads; i++) {
</span></span><span style=display:flex><span>            result = result.multiply(workers[i].result);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private static class FactComputer implements Runnable {
</span></span><span style=display:flex><span>        BigDecimal result;
</span></span><span style=display:flex><span>        private final <span style=color:#fff;font-weight:700>int</span> from;
</span></span><span style=display:flex><span>        private final <span style=color:#fff;font-weight:700>int</span> to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        public FactComputer(<span style=color:#fff;font-weight:700>int</span> from, <span style=color:#fff;font-weight:700>int</span> to) {
</span></span><span style=display:flex><span>            this.from = from;
</span></span><span style=display:flex><span>            this.to = to;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        public void run() {
</span></span><span style=display:flex><span>            result = BigDecimal.valueOf(from);
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i = from + <span style=color:#ff0;font-weight:700>1</span>; i &lt;= to; i++) {
</span></span><span style=display:flex><span>                result = result.multiply(BigDecimal.valueOf(i));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here is the result in <code>System.out</code>:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>56 seconds for 1 thread
</span></span><span style=display:flex><span>26 seconds for 4 threads
</span></span></code></pre></div><p>I have written it as the unit test to be sure that at least this simplistic distribution of work between threads has no bugs (I tested it with different values of INPUT). I think it is obvious from this code that I run it on the 4-core processor. Actually on the 2-core but with hyper-threading enabled.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2023
Ivan Sopov
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js integrity="sha256-nPLb+baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script></body></html>