<!doctype html><html lang=en><head><title>Multithreaded factorial with ThreadPoolExecutor · isopov
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ivan Sopov"><meta name=description content="Update: the follow up post gives another version using newly introduced API.
In the previous post I have written a multithreaded factorial. It was not really good, because last one of the worker threads worked significantly longer than the first one. Fortunately we are living in 2011 and Java 1.5 was released so long time ago. The solution is simple - do not create 4 threads of the 4 virtual cores processors."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Multithreaded factorial with ThreadPoolExecutor"><meta name=twitter:description content="Update: the follow up post gives another version using newly introduced API.
In the previous post I have written a multithreaded factorial. It was not really good, because last one of the worker threads worked significantly longer than the first one. Fortunately we are living in 2011 and Java 1.5 was released so long time ago. The solution is simple - do not create 4 threads of the 4 virtual cores processors."><meta property="og:url" content="https://isopov.github.io/posts/multithreaded-factorial-with-threadpoolexecutor/"><meta property="og:site_name" content="isopov"><meta property="og:title" content="Multithreaded factorial with ThreadPoolExecutor"><meta property="og:description" content="Update: the follow up post gives another version using newly introduced API.
In the previous post I have written a multithreaded factorial. It was not really good, because last one of the worker threads worked significantly longer than the first one. Fortunately we are living in 2011 and Java 1.5 was released so long time ago. The solution is simple - do not create 4 threads of the 4 virtual cores processors."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-07-22T10:00:17+03:00"><meta property="article:modified_time" content="2011-07-22T10:00:17+03:00"><meta property="article:tag" content="Java"><link rel=canonical href=https://isopov.github.io/posts/multithreaded-factorial-with-threadpoolexecutor/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.38c4552ac40f9ae3408bad40358f654ebd8804412fe74ed56f2d6c8a7af82dd3.css integrity="sha256-OMRVKsQPmuNAi61ANY9lTr2IBEEv507Vby1sinr4LdM=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://isopov.github.io/>isopov
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://isopov.github.io/posts/multithreaded-factorial-with-threadpoolexecutor/>Multithreaded factorial with ThreadPoolExecutor</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2011-07-22T10:00:17+03:00>July 22, 2011
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
2-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>Java</a></span></div></div></header><div class=post-content><p><strong>Update</strong>: <a href=https://isopov.github.io/posts/forkjoin-factorial/>the follow up post</a> gives another version using newly introduced API.</p><p>In the <a href=https://isopov.github.io/posts/multithreaded-factorial/>previous post</a> I have written a multithreaded factorial. It was not really good, because last one of the worker threads worked significantly longer than the first one. Fortunately we are living in 2011 and Java 1.5 was released so long time ago. The solution is simple - do not create 4 threads of the 4 virtual cores processors. Create really many threads and let the standard concurrent library execute them all. So ok, here is the code for this:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>    private static BigInteger factMtExecutor(int input, int numThreads)
</span></span><span style=display:flex><span>            throws InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        FactCallable[] workers = new FactCallable[100];
</span></span><span style=display:flex><span>        for (int i = 1; i &lt;= 100; i++) {
</span></span><span style=display:flex><span>            int start = i == 1 ? 1 : (input / 100 * (i - 1)) + 1;
</span></span><span style=display:flex><span>            int end = i == 100 ? input : input / 100 * i;
</span></span><span style=display:flex><span>            workers[i - 1] = new FactCallable(start, end);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor executor = new ThreadPoolExecutor(numThreads,
</span></span><span style=display:flex><span>                numThreads, 0, TimeUnit.SECONDS,
</span></span><span style=display:flex><span>                new LinkedBlockingQueue&lt;Runnable&gt;());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        List&lt;Future&lt;BigInteger&gt;&gt; futures = executor.invokeAll(Arrays
</span></span><span style=display:flex><span>                .asList(workers));
</span></span><span style=display:flex><span>        BigInteger result = BigInteger.valueOf(1L);
</span></span><span style=display:flex><span>        for (Future&lt;BigInteger&gt; future : futures) {
</span></span><span style=display:flex><span>            result = result.multiply(future.get());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private static class FactCallable implements Callable&lt;BigInteger&gt; {
</span></span><span style=display:flex><span>        private final int from;
</span></span><span style=display:flex><span>        private final int to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        public FactCallable(int from, int to) {
</span></span><span style=display:flex><span>            this.from = from;
</span></span><span style=display:flex><span>            this.to = to;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        @Override
</span></span><span style=display:flex><span>        public BigInteger call() throws Exception {
</span></span><span style=display:flex><span>            BigInteger result = BigInteger.valueOf(from);
</span></span><span style=display:flex><span>            for (int i = from + 1; i &lt;= to; i++) {
</span></span><span style=display:flex><span>                result = result.multiply(BigInteger.valueOf(i));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            return result;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And the result comparing to the previous version:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>35 seconds for simple start/join
</span></span><span style=display:flex><span>25 seconds for ThreadPoolExecutor
</span></span><span style=display:flex><span>``
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>And the second time, swapping the order of execution:
</span></span></code></pre></div><p>29 seconds for ThreadPoolExecutor
38 seconds for simple start/join</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Full code for comparison may be found on [github](https://gist.github.com/1098118).
</span></span></code></pre></div></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2011 -
2024
Ivan Sopov
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>