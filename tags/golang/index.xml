<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on isopov</title><link>https://isopov.github.io/tags/golang/</link><description>Recent content in Golang on isopov</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 05 Oct 2023 13:30:49 +0300</lastBuildDate><atom:link href="https://isopov.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go map of maps of maps vs complex keys</title><link>https://isopov.github.io/posts/go-map-of-maps-of-maps/</link><pubDate>Thu, 05 Oct 2023 13:30:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-map-of-maps-of-maps/</guid><description>In other languages I&amp;rsquo;ve seen single map performing better than a map of maps or even map of maps of maps. I wanted to test which way is better in Go. So I wrote this test:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;testing&amp;#34; ) type structID struct { first int second int third int } var Blackholemapmapmap map[int]map[int]map[int]string var Blackholemapstruct map[structID]string func BenchmarkName(b *testing.B) { b.Run(&amp;#34;mapmapmap def maps&amp;#34;, func(b *testing.B) { b.</description></item><item><title>Go channel(s) contention</title><link>https://isopov.github.io/posts/go-channel-contention/</link><pubDate>Mon, 27 Mar 2023 20:22:39 +0300</pubDate><guid>https://isopov.github.io/posts/go-channel-contention/</guid><description>In the previous post I&amp;rsquo;ve tried to measure overhead from highly contended access to sync.Pool on go. There was some measurable overhead, but it was mild. However in order for another goroutine to recieve some work to be done or/and to publish work results you may need go channel also. In this post I&amp;rsquo;ll try to measure the overhead of contended access to go channel.
So I&amp;rsquo;ve written the following code</description></item><item><title>Growing goroutine stacks</title><link>https://isopov.github.io/posts/goroutine-stack-grow/</link><pubDate>Fri, 24 Mar 2023 20:22:39 +0300</pubDate><guid>https://isopov.github.io/posts/goroutine-stack-grow/</guid><description>Go allows to run very lightweight goroutines and throw them away (for garbage collector) after they are no longer needed. You can execute any code inside them and this caode can allocate as much as needed. Both on stack and on heap. If goroutine stack is too small it grows. This grow is not free. Suppose you have a widely used function that needs to allocate a bit of memory on stack.</description></item><item><title>Go sync.Pool contention</title><link>https://isopov.github.io/posts/sync-pool-contention/</link><pubDate>Fri, 24 Mar 2023 16:22:39 +0300</pubDate><guid>https://isopov.github.io/posts/sync-pool-contention/</guid><description>Recently my colleague suggested that contention on a single sync.Pool in Go may hit performance. I decided to reproduce this performance hit in a benchmark. This is what I was capable of writing.
import ( &amp;#34;runtime&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;sync/atomic&amp;#34; &amp;#34;testing&amp;#34; ) func workWithPool(pool *sync.Pool) { const size = 1000 values := [size]int{} for i := 0; i &amp;lt; size; i++ { values[i] = pool.Get().(int) } for i := 0; i &amp;lt; size; i++ { pool.</description></item><item><title>Go sync.Pool and gc</title><link>https://isopov.github.io/posts/go-sync-pool-2/</link><pubDate>Tue, 01 Mar 2022 13:10:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-sync-pool-2/</guid><description>I&amp;rsquo;ve posted my brief experiments with sync.Pool in go. However, reading about it guides that it may be hard to use tool. And sometimes it can degrade for third-party reasons. It is easy to trap into old information regarding sync.Pool and gc interrogation. Since go 1.13 sync.Pool is not cleared completely on every gc. However, it is still affected by gc. Suppose the following code:
type Obj []int func (o *Obj) Fill() { for i := 0; i &amp;lt; cap(*o); i++ { *o = append(*o, i) } } func (o Obj) Count() int { result := 0 for i := 0; i &amp;lt; len(o); i++ { result += o[i] } return result } func NewObj() *Obj { o := make(Obj, 0, 100*1024) return &amp;amp;o } var objPool = &amp;amp;sync.</description></item><item><title>Go sync.Pool</title><link>https://isopov.github.io/posts/go-sync-pool/</link><pubDate>Fri, 25 Feb 2022 13:30:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-sync-pool/</guid><description>Recently I&amp;rsquo;ve seen sync.Pools in various Go libraries. Sometimes I wondered wether it is worth using at all. So I wrote some tests. Here are they:
package main import ( &amp;#34;crypto/sha256&amp;#34; &amp;#34;hash&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;testing&amp;#34; ) var shaPool = &amp;amp;sync.Pool{ New: func() interface{} { return sha256.New() }, } var HashTrap hash.Hash var Source = []byte(strings.ToLower(&amp;#34;asdfavzxcvsdfqawesfdz&amp;#34;)) var ResultTrap []byte func Benchmark(b *testing.B) { b.Run(&amp;#34;Pool&amp;#34;, func(b *testing.B) { b.ReportAllocs() for i := 0; i &amp;lt; b.</description></item><item><title>Go scheduler fairness</title><link>https://isopov.github.io/posts/go-scheduler-fairness/</link><pubDate>Fri, 02 Apr 2021 18:30:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-scheduler-fairness/</guid><description>Recently in Jaeger I stumbled at an interesting trace - the work was done for 1 second, than 20 there was a gap for 20 seconds and after that work continued. My best guess currently is that goroutine slept for 20 seconds. To reproduce it I wrote the following:
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync/atomic&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/couchbaselabs/ghistogram&amp;#34; ) func main() { runtime.GOMAXPROCS(1) ctx, cancel := context.WithCancel(context.Background()) workers := 300 done := make([]chan bool, workers) for i := 0; i &amp;lt; workers; i++ { done[i] = make(chan bool) } times := ghistogram.</description></item><item><title>Moving work to another goroutine</title><link>https://isopov.github.io/posts/moving-work-to-goroutine/</link><pubDate>Tue, 30 Mar 2021 12:25:42 +0300</pubDate><guid>https://isopov.github.io/posts/moving-work-to-goroutine/</guid><description>Concurency in Go is super easy. Still to write it inside my very large work project I first needed to get my hands with it on really small and simple example. So I wrote one and it seems that this blog is a perfect place to store it.
package main import ( &amp;#34;time&amp;#34; ) func main() { worker := make(chan int, 10) done := make(chan bool) go func() { for data := range worker { time.</description></item><item><title>Using map[]struct{} or map[]bool in Golang</title><link>https://isopov.github.io/posts/map-bool-or-struct/</link><pubDate>Sun, 01 Nov 2020 13:35:52 +0300</pubDate><guid>https://isopov.github.io/posts/map-bool-or-struct/</guid><description>In Golang you do not have set data structure. So you can use map instead. When you do not need values there are two options widely used - using empty struct{} or bool as value. struct{} should be more performant, while bool is more convinient. I decided to check the first promise myslef. Golang have benchamrks support in its standard library. SO I wrote this one:
package mapstruct import ( &amp;#34;math/rand&amp;#34; &amp;#34;testing&amp;#34; ) func input() []int { slice := make([]int, 10_000) for i := 0; i &amp;lt; 10_000; i++ { slice[i] = rand.</description></item></channel></rss>