<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on isopov</title><link>https://isopov.github.io/tags/golang/</link><description>Recent content in Golang on isopov</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 25 Feb 2022 13:30:49 +0300</lastBuildDate><atom:link href="https://isopov.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go sync.Pool</title><link>https://isopov.github.io/posts/go-sync-pool/</link><pubDate>Fri, 25 Feb 2022 13:30:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-sync-pool/</guid><description>Recently I&amp;rsquo;ve seen sync.Pools in various Go libraries. Sometimes I wondered wether it is worth using at all. So I wrote some tests. Here are they:
package main import ( &amp;#34;crypto/sha256&amp;#34; &amp;#34;hash&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;testing&amp;#34; ) var shaPool = &amp;amp;sync.Pool{ New: func() interface{} { return sha256.New() }, } var HashTrap hash.Hash var Source = []byte(strings.ToLower(&amp;#34;asdfavzxcvsdfqawesfdz&amp;#34;)) var ResultTrap []byte func Benchmark(b *testing.B) { b.Run(&amp;#34;Pool&amp;#34;, func(b *testing.B) { b.ReportAllocs() for i := 0; i &amp;lt; b.</description></item><item><title>Go scheduler fairness</title><link>https://isopov.github.io/posts/go-scheduler-fairness/</link><pubDate>Fri, 02 Apr 2021 18:30:49 +0300</pubDate><guid>https://isopov.github.io/posts/go-scheduler-fairness/</guid><description>Recently in Jaeger I stumbled at an interesting trace - the work was done for 1 second, than 20 there was a gap for 20 seconds and after that work continued. My best guess currently is that goroutine slept for 20 seconds. To reproduce it I wrote the following:
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync/atomic&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/couchbaselabs/ghistogram&amp;#34; ) func main() { runtime.GOMAXPROCS(1) ctx, cancel := context.WithCancel(context.Background()) workers := 300 done := make([]chan bool, workers) for i := 0; i &amp;lt; workers; i++ { done[i] = make(chan bool) } times := ghistogram.</description></item><item><title>Moving work to another goroutine</title><link>https://isopov.github.io/posts/moving-work-to-goroutine/</link><pubDate>Tue, 30 Mar 2021 12:25:42 +0300</pubDate><guid>https://isopov.github.io/posts/moving-work-to-goroutine/</guid><description>Concurency in Go is super easy. Still to write it inside my very large work project I first needed to get my hands with it on really small and simple example. So I wrote one and it seems that this blog is a perfect place to store it.
package main import ( &amp;#34;time&amp;#34; ) func main() { worker := make(chan int, 10) done := make(chan bool) go func() { for data := range worker { time.</description></item><item><title>Using map[]struct{} or map[]bool in Golang</title><link>https://isopov.github.io/posts/map-bool-or-struct/</link><pubDate>Sun, 01 Nov 2020 13:35:52 +0300</pubDate><guid>https://isopov.github.io/posts/map-bool-or-struct/</guid><description>In Golang you do not have set data structure. So you can use map instead. When you do not need values there are two options widely used - using empty struct{} or bool as value. struct{} should be more performant, while bool is more convinient. I decided to check the first promise myslef. Golang have benchamrks support in its standard library. SO I wrote this one:
package mapstruct import ( &amp;#34;math/rand&amp;#34; &amp;#34;testing&amp;#34; ) func input() []int { slice := make([]int, 10_000) for i := 0; i &amp;lt; 10_000; i++ { slice[i] = rand.</description></item></channel></rss>